#!/usr/bin/env bash
set -e
set -u
set -o pipefail

# Creates and returns a random temporary directory
#
# returns string
#
# @ random-tmpdir
random-tmpdir() {
    echo $(mktemp -d)
}

# Recursively ensure a directory exists.
#
# @ recursive-mkdir <dir>
recursive-mkdir() {
    local _dir=
    _dir="${1:?}"

    mkdir -p $_dir
    debug "[recursive-mkdir]: created dir ${_dir}"
}

# Recursively deletes a file or directory.
# DANGEROUS! No safeguards.
#
# @ recursive-rm <dir>
recursive-rm() {
    local _file=
    _file="${1:?}"

    rm -rf "${1:?}"
    debug "[recursive-rm] ***********************"
    debug "[recursive-rm] *** removed $_file ***"
    debug "[recursive-rm] ***********************"
}

# safe wrapper to remove a directory. contains a series
# of logic checks to ensure specific directories are
# not deleted.
#
# returns boolean
#
# @ ensure-file-absent <dir>
ensure-file-absent() {
    local _target=
    _target="${1:?}"

    if directory-exists $_target || file-exists $_target;
    then recursive-rm $_target ;
    else true;
    fi
}

# safe wrapper to create a directory. skips unnecessary checks
# by doing some prodding around before it blindly creates a directory
#
# returns boolean
#
# @ ensure-directory-exists <dir>
ensure-directory-exists() {
    local _dir=
    _dir="${1:?}"

    if directory-does-not-exist $_dir;
    then recursive-mkdir $_dir;
    else true;
    fi
}

# logic check to determine if a directory is absent on the fs
# inverse of `directory-exists`
#
# returns boolean
#
# @ directory-does-not-exist <dir>
directory-does-not-exist() {
    ! directory-exists "${1:?}"
}

# logic check to determine if a directory exists on the fs
# returns boolean
#
# @ directory-exists <dir>
directory-exists() {
    if [[ -d "${1:?}" ]];
    then true;
    else false;
    fi
}

# recursively copy files or directories from one place to
# another.
#
# @ recursive-copy <src> <dst>
recursive-copy() {
    local _src=
    local _dst=
    _src="${1:?}"
    _dst="${2:?}"

    cp -R $_src $_dst
    debug "[recursive-copy]: completed copy from ${_src} to ${_dst}"
}

# copy a file or directory from one place to another. automatically
# backs up any file if it exists with a epoch timestamp.
#
# @ safe-copy /tmp/installer /opt/stackstorm/installer
safe-copy() {
    local _source=
    local _dest=
    local _backup=
    _source="${1:?}"
    _dest="${2:?}"
    _backup="${_dest}.$(current-epoch)"

    if directory-exists $_dest || file-exists $_dest;
    then recursive-copy $_dest $_backup
    fi

    ensure-file-absent $_dest
    recursive-copy $_source $_dest
}

# deletes a file by creating a backup of itself with an epoch
# timestamp. Ensures the original file/dir is removed
#
# @ safe-delete /tmp/installer
safe-delete() {
    local _dir=
    local _backup_dir=
    _source_dir="${1:?}"
    _backup_dir="${_dir}.$(current-epoch)"

    ensure-file-absent $_backup_dir
    recursive-copy $_dir $_backup_dir
    recursive-rm $_dir
}

# touches a file on the file-system only if it doesn't exist
#
# @ ensure-file-exists <file>
ensure-file-exists() {
    local _file=
    _file="${1:?}"

    if file-does-not-exist $_file;
    then
        touch $_file
        debug "[ensure-file-exists]: touched new file ${_file}"
    fi
}

# tests to determine if a file exists on the file-system
# inverse of `file-exists`
#
# returns boolean
#
# @ file-does-not-exist <file>
file-does-not-exist() {
    ! file-exists "${1:?}"
}

# tests to determine if a file exists on the file-system
#
# returns boolean
#
# @ file-exists <file>
file-exists() {
    if [[ -f "${1:?}" ]];
    then true;
    else false;
    fi
}

# tests to determine if an executable is in the current running
# environment. like: `which`
#
# returns boolean
#
# @ executable-in-path 'st2'
executable-in-path() {
    if hash "${1:?}" 2>/dev/null;
    then true;
    else false;
    fi
}

# tests to determine if an executable is not in the current running
# environment. like: `which`. Inverse of `executable-in-path`
#
# returns boolean
#
# @ executable-not-in-path 'st2'
executable-not-in-path() {
    ! executable-in-path "${1:?}"
}

# echo a string to a completely new file. Takes a backup of the destination
# if it happens to exist before taking action.
#
# @ echo-to-new-file <message> <filename>
echo-to-new-file() {
    local _message=
    local _file=
    _message="${1:?}"
    _file="${2:?}"

    safe-copy $_file "${_file}.$(current-epoch)"
    ensure-file-absent $_file
    echo-to-file $_message $_file
}

# echo a string to a file, appending to the file itself
#
# @ echo-to-file <message> <file>
echo-to-file() {
    local _message="${1:?}"
    local _dest="${2:?}"

    echo "${message}" >> $_dest
    debug "[echo-to-file]: echoed '${_message}' to ${_dest}"
}
