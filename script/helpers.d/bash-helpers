#!/usr/bin/env bash
set -e
set -u
set -o pipefail

# check to determine if a bash variable has a value
# Inverse of 'variable-not-set'
#
# returns boolean
#
# @ variable-set <ENV>
variable-set() {
    ! variable-not-set $@
}

# check to determine if a bash variable is not set
#
# returns boolean
#
# @ variable-not-set <ENV>
variable-not-set() {
    if [[ -z "${1:?}" ]];
    then true;
    else false;
    fi
}

# determine if a string equals another string
#
# returns boolean
#
# @ string-equals <str1> <str2>
string-equals() {
    # Unset fail on unset variables
    set +u

    if [[ "${1:-}" = "${2:-}" ]];
    then true;
    else false;
    fi

    # and then turn it back on for safety
    set -u
}

integer-not-equals() {
    ! integer-equals "${1:?}" "${2:?}"
}

integer-equals() {
    # Unset fail on unset variables
    set +u

    if [[ $1 -eq $2 ]];
    then true;
    else false;
    fi

    # and then turn it back on for safety
    set -u


}

# execute the command stored in a string
#
# @ execute-string <str>
execute-string() {
    eval "${@}"
}

# quietly chdir
#
# pushd-quiet <dir>
pushd-quiet() {
    pushd "${1:?}" >> /dev/null 2>&1
}

# chdir to the previous dir in the stack
#
# pushd-stepback
pushd-stepback() {
    pushd-quiet +1
}

# show the current directory at runtime
#
# returns string
#
# current-directory
current-directory() {
    echo "$(pwd)"
}

# Determine if command successfully ran
#
# returns boolean
#
# command-successfully-run <cmd>
command-successfully-run() {
    execute-string "${1:?}"

    if [ $? -eq 0 ];
    then true;
    else false;
    fi
}

# converts an array to a string for passing to
# another function. Adopted from Matt McClure
# bash v2.
#
# http://notes-matthewlmcclure.blogspot.com/2009/12/return-array-from-bash-function-v-2.html
#
# Unfortunately, it is impossible to get rid of all bashisms, so
# if needed, here is how to unpack from this function:
#
#    _unpack_var="declare -a $_new_var=$(some-return-function)"
#    execute-string "${_unpack_system_dirs}"
#
# at which point, $_new_var will be in scope.
#
# Use sparingly, usually only to separate data from control
#
# @ array-to-string <array>
array-to-string()
{
    local -a array=( "$@" )
    declare -p array | sed -e 's/^declare -a array=//'
}

replace-file-extension() {
    echo "${1##.*:?}.${2:?}"
}
